/**
 * ORBT Validator â€“ Build-Time Linter and Compliance Logger for Repo Lens
 * Purpose: Validate all Repo Lens build outputs (modules, docs, visuals) against ORBT structure + Barton Numbering
 */

import { z } from "zod"
import { ORPTSystem, ORPTModule, ORPTStatus } from "./orpt-system"
import { BartonNumberingDoctrine, validateBartonNumber, parseBartonNumber } from "./barton-numbering-doctrine"
import { logBartonEvent, BartonPrinciple } from "./enhanced-barton"

// 1. Define universal ORBT validator schema
const orbtSchema = z.object({
  barton_number: z
    .string()
    .regex(/^(\d+)\.(app|mod|submod|diag|doc)\.[a-z0-9_-]+$/, "Invalid Barton Number format"),
  orbt_type: z.enum(["Operating", "Repair", "Build", "Training"]),
  orbt_phase: z.enum(["design", "active", "troubleshoot", "archived"]),
  doc_exists: z.boolean(),
  visual_exists: z.boolean(),
  repair_log_exists: z.boolean().optional(),
})

// Enhanced ORBT schema for Repo Lens v2
const orbtV2Schema = z.object({
  barton_number: z
    .string()
    .regex(/^39\.\d{2}\.\d{2}\.\d{2}$/, "Invalid Barton Number format for Repo Lens (Blueprint 39)"),
  blueprint_id: z.string().regex(/^BP-039$/, "Invalid Blueprint ID for Repo Lens"),
  orpt_sections: z.object({
    operating: z.object({
      purpose: z.string().min(1, "Operating purpose is required"),
      expectedBehavior: z.string().min(1, "Expected behavior is required"),
      dependencies: z.array(z.string()).min(1, "At least one dependency required"),
      interfaces: z.array(z.string()).min(1, "At least one interface required"),
      status: z.nativeEnum(ORPTStatus),
    }),
    repair: z.object({
      repairLog: z.array(z.any()).min(0, "Repair log array required"),
      totalErrors: z.number().min(0, "Total errors must be non-negative"),
      totalFixes: z.number().min(0, "Total fixes must be non-negative"),
      escalationCount: z.number().min(0, "Escalation count must be non-negative"),
      troubleshootingTips: z.array(z.string()).min(1, "At least one troubleshooting tip required"),
      status: z.nativeEnum(ORPTStatus),
    }),
    parts: z.object({
      keyFiles: z.array(z.object({
        path: z.string().min(1, "File path is required"),
        type: z.enum(["component", "service", "utility", "config", "test"]),
        description: z.string().min(1, "File description is required"),
        bartonNumber: z.string().regex(/^39\.\d{2}\.\d{2}\.\d{2}$/, "Invalid file Barton number"),
        clickable: z.boolean(),
      })).min(1, "At least one key file required"),
      components: z.array(z.object({
        name: z.string().min(1, "Component name is required"),
        file: z.string().min(1, "Component file is required"),
        description: z.string().min(1, "Component description is required"),
        dependencies: z.array(z.string()),
      })).min(1, "At least one component required"),
      imports: z.array(z.string()),
      exports: z.array(z.string()),
      status: z.nativeEnum(ORPTStatus),
    }),
    training: z.object({
      usageInstructions: z.string().min(1, "Usage instructions are required"),
      cliCommands: z.array(z.string()).min(1, "At least one CLI command required"),
      uiInstructions: z.array(z.string()).min(1, "At least one UI instruction required"),
      troubleshootingGuide: z.string().min(1, "Troubleshooting guide is required"),
      errorSignatures: z.array(z.object({
        pattern: z.string().min(1, "Error pattern is required"),
        description: z.string().min(1, "Error description is required"),
        solution: z.string().min(1, "Error solution is required"),
      })).min(1, "At least one error signature required"),
      examples: z.array(z.object({
        title: z.string().min(1, "Example title is required"),
        description: z.string().min(1, "Example description is required"),
        code: z.string().optional(),
      })).min(1, "At least one example required"),
      status: z.nativeEnum(ORPTStatus),
    }),
  }),
  visualDiagram: z.object({
    type: z.enum(["flow", "dependency", "component", "architecture"]),
    data: z.any(),
    filePath: z.string().min(1, "Visual diagram file path is required"),
    clickable: z.boolean(),
    depth: z.enum(["30k", "20k", "10k", "5k"]),
  }),
  documentation: z.object({
    markdown: z.string().min(1, "Documentation markdown is required"),
    autoGenerated: z.boolean(),
    lastGenerated: z.date(),
    schema: z.object({
      stamped: z.any(),
      spvpet: z.any(),
      stacked: z.any(),
    }),
    crossLinks: z.array(z.string()),
    version: z.string().min(1, "Documentation version is required"),
  }),
  overallStatus: z.nativeEnum(ORPTStatus),
  errorCount: z.number().min(0, "Error count must be non-negative"),
  lastHealthCheck: z.date(),
  escalationLevel: z.number().min(0).max(3, "Escalation level must be 0-3"),
  buildTimestamp: z.date(),
  runtimeStatus: z.enum(["operational", "degraded", "failed"]),
  schemaCompliance: z.number().min(0).max(100, "Schema compliance must be 0-100"),
})

interface ValidationError {
  source: string
  module: string
  barton_number: string
  errors: any
  timestamp: string
  severity: 'low' | 'medium' | 'high' | 'critical'
  suggestedFix: string
}

interface FixPayload {
  module: string
  barton_number: string
  missingFields: string[]
  suggestedFix: string
  priority: 'low' | 'medium' | 'high' | 'critical'
  autoFixable: boolean
}

class ORBTValidator {
  private static instance: ORBTValidator
  private errors: ValidationError[] = []
  private fixPayloads: FixPayload[] = []
  private orptSystem: ORPTSystem
  private bartonDoctrine: BartonNumberingDoctrine

  private constructor() {
    this.orptSystem = ORPTSystem.getInstance()
    this.bartonDoctrine = BartonNumberingDoctrine.getInstance()
  }

  static getInstance(): ORBTValidator {
    if (!ORBTValidator.instance) {
      ORBTValidator.instance = new ORBTValidator()
    }
    return ORBTValidator.instance
  }

  // Write error to centralized error log
  async writeToErrorLog(error: ValidationError): Promise<void> {
    this.errors.push(error)
    
    // Log to ORPT system
    this.orptSystem.logRepairEntry({
      errorType: 'schema',
      errorMessage: `ORBT validation failed: ${error.errors}`,
      errorSignature: 'ORBT_VALIDATION_FAILED',
      severity: error.severity,
      toolUsed: 'ORBT_Validator',
      fixDescription: error.suggestedFix,
      resolved: false,
      recurrenceCount: 1,
      escalated: false,
      bartonNumber: error.barton_number,
      moduleId: error.module
    })

    // Log to Barton system
    logBartonEvent(
      BartonPrinciple.ERROR_ESCALATION,
      `ORBT validation failed for ${error.module}: ${error.errors}`,
      'error',
      'orbt_validator',
      { 
        moduleId: error.module, 
        bartonNumber: error.barton_number,
        errors: error.errors 
      }
    )

    console.error(`[ORBT Validator] ${error.module} (${error.barton_number}): ${error.errors}`)
  }

  // Push fix payload for auto-resolution
  async pushFixPayload(payload: FixPayload): Promise<void> {
    this.fixPayloads.push(payload)
    
    // Attempt auto-fix for low priority issues
    if (payload.priority === 'low' && payload.autoFixable) {
      await this.attemptAutoFix(payload)
    }

    console.log(`[ORBT Validator] Fix payload for ${payload.module}: ${payload.suggestedFix}`)
  }

  // Attempt automatic fixes for common issues
  private async attemptAutoFix(payload: FixPayload): Promise<boolean> {
    try {
      const module = this.orptSystem.getModule(payload.module)
      if (!module) return false

      // Auto-fix missing Barton number
      if (payload.missingFields.includes('barton_number')) {
        const bartonNumber = this.bartonDoctrine.generateBartonNumberFromPath(module.id)
        module.bartonNumber = bartonNumber.toString()
        return true
      }

      // Auto-fix missing ORPT sections
      if (payload.missingFields.includes('orpt_sections')) {
        // Add default ORPT sections
        if (!module.operating.purpose) {
          module.operating.purpose = `Default purpose for ${module.name}`
        }
        if (!module.repair.troubleshootingTips.length) {
          module.repair.troubleshootingTips = ['Check module configuration', 'Verify dependencies']
        }
        if (!module.parts.keyFiles.length) {
          module.parts.keyFiles = [{
            path: `${module.id}/index.tsx`,
            type: 'component',
            description: `Main component for ${module.name}`,
            bartonNumber: module.bartonNumber,
            clickable: true
          }]
        }
        if (!module.training.usageInstructions) {
          module.training.usageInstructions = `Navigate to ${module.id} to use this module`
        }
        return true
      }

      return false
    } catch (error) {
      console.error(`[ORBT Validator] Auto-fix failed for ${payload.module}:`, error)
      return false
    }
  }

  // Get all modules from Repo Lens
  private getAllModulesFromRepoLens(): ORPTModule[] {
    return this.orptSystem.getAllModules()
  }

  // Validate single module against ORBT schema
  private validateModule(module: ORPTModule): { success: boolean; errors?: any } {
    try {
      // Validate against ORBT v2 schema
      const result = orbtV2Schema.safeParse(module)
      
      if (!result.success) {
        return { success: false, errors: result.error.format() }
      }

      // Additional Barton number validation
      if (!validateBartonNumber(module.bartonNumber)) {
        return { 
          success: false, 
          errors: { barton_number: { _errors: ['Invalid Barton number format'] } }
        }
      }

      // Check if component exists in Barton doctrine
      const component = this.bartonDoctrine.getComponentByBartonNumber(module.bartonNumber)
      if (!component) {
        return { 
          success: false, 
          errors: { barton_number: { _errors: ['Component not registered in Barton doctrine'] } }
        }
      }

      return { success: true }
    } catch (error) {
      return { 
        success: false, 
        errors: { _errors: [`Validation error: ${error}`] }
      }
    }
  }

  // Run comprehensive validation across all modules
  async runValidation(): Promise<{
    totalModules: number
    validModules: number
    invalidModules: number
    errors: ValidationError[]
    fixPayloads: FixPayload[]
  }> {
    console.log('[ORBT Validator] Starting comprehensive validation...')
    
    const modules = this.getAllModulesFromRepoLens()
    let validCount = 0
    let invalidCount = 0

    for (const module of modules) {
      const result = this.validateModule(module)

      if (!result.success) {
        invalidCount++
        
        // Determine severity based on error types
        const errorFields = Object.keys(result.errors || {})
        let severity: 'low' | 'medium' | 'high' | 'critical' = 'low'
        
        if (errorFields.includes('barton_number')) severity = 'high'
        if (errorFields.includes('orpt_sections')) severity = 'medium'
        if (errorFields.includes('documentation')) severity = 'low'

        // Write error to log
        await this.writeToErrorLog({
          source: "orbt_validator",
          module: module.name,
          barton_number: module.bartonNumber,
          errors: result.errors,
          timestamp: new Date().toISOString(),
          severity,
          suggestedFix: "Please reference ORBT baseline schema from doctrine table `dpr_doctrine`."
        })

        // Push fix payload
        await this.pushFixPayload({
          module: module.name,
          barton_number: module.bartonNumber,
          missingFields: errorFields,
          suggestedFix: "Please reference ORBT baseline schema from doctrine table `dpr_doctrine`.",
          priority: severity,
          autoFixable: severity === 'low'
        })
      } else {
        validCount++
      }
    }

    console.log(`[ORBT Validator] Validation complete: ${validCount} valid, ${invalidCount} invalid modules`)

    return {
      totalModules: modules.length,
      validModules: validCount,
      invalidModules: invalidCount,
      errors: this.errors,
      fixPayloads: this.fixPayloads
    }
  }

  // Generate compliance report
  generateComplianceReport(): any {
    const modules = this.getAllModulesFromRepoLens()
    const validation = this.runValidation()
    
    return {
      timestamp: new Date().toISOString(),
      totalModules: modules.length,
      validation,
      errors: this.errors,
      fixPayloads: this.fixPayloads,
      complianceScore: modules.length > 0 ? 
        ((modules.length - this.errors.length) / modules.length) * 100 : 100,
      recommendations: this.generateRecommendations()
    }
  }

  // Generate recommendations for improvement
  private generateRecommendations(): string[] {
    const recommendations: string[] = []

    if (this.errors.length > 0) {
      recommendations.push(`Fix ${this.errors.length} validation errors to improve compliance`)
    }

    const modules = this.getAllModulesFromRepoLens()
    const modulesWithLowCompliance = modules.filter(m => m.schemaCompliance < 80)
    
    if (modulesWithLowCompliance.length > 0) {
      recommendations.push(`Improve schema compliance for ${modulesWithLowCompliance.length} modules`)
    }

    const modulesWithoutVisuals = modules.filter(m => !m.visualDiagram.data)
    if (modulesWithoutVisuals.length > 0) {
      recommendations.push(`Add visual diagrams for ${modulesWithoutVisuals.length} modules`)
    }

    return recommendations
  }

  // Clear validation state
  clearValidationState(): void {
    this.errors = []
    this.fixPayloads = []
  }

  // Get validation statistics
  getValidationStats(): {
    totalErrors: number
    errorsBySeverity: Record<string, number>
    errorsByModule: Record<string, number>
    autoFixableErrors: number
  } {
    const errorsBySeverity: Record<string, number> = {}
    const errorsByModule: Record<string, number> = {}
    let autoFixableErrors = 0

    this.errors.forEach(error => {
      errorsBySeverity[error.severity] = (errorsBySeverity[error.severity] || 0) + 1
      errorsByModule[error.module] = (errorsByModule[error.module] || 0) + 1
      
      if (error.severity === 'low') {
        autoFixableErrors++
      }
    })

    return {
      totalErrors: this.errors.length,
      errorsBySeverity,
      errorsByModule,
      autoFixableErrors
    }
  }
}

// Export singleton instance
export const orbtValidator = ORBTValidator.getInstance()

// Export types for external use
export type { ValidationError, FixPayload }

// Export validation functions
export async function validateRepoLensBuild(): Promise<any> {
  return await orbtValidator.runValidation()
}

export function generateORBTComplianceReport(): any {
  return orbtValidator.generateComplianceReport()
}

export function getORBTValidationStats(): any {
  return orbtValidator.getValidationStats()
}

// Legacy schema for backward compatibility
export { orbtSchema, orbtV2Schema } 